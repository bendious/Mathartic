//For x64 Visual Studio command line:  cl.exe /LD /D GLEW_STATIC RuntimeShader.cpp GLEW/glew.c opengl32.lib

#include "Unity/PlatformBase.h"
#include "Unity/IUnityGraphics.h"

#if UNITY_IPHONE
#include <OpenGLES/ES2/gl.h>
#elif UNITY_ANDROID || UNITY_WEBGL
#include <GLES2/gl2.h>
#else
#if !defined(SUPPORT_OPENGL_CORE)
#error "Unsupported rendering environment"
#endif
#include "GLEW/glew.h"
#endif

#if defined(DEBUG)
#include <cstring>
#include <stdio.h>
#endif


#define CEXPORT(return_type) extern "C" return_type __declspec(dllexport) __stdcall

typedef void (__stdcall* IUnityGraphicsDeviceEventCallback)(UnityGfxDeviceEventType eventType);
typedef void (__stdcall* UnregisterDeviceEventCallback)(IUnityGraphicsDeviceEventCallback callback);


static IUnityInterfaces* s_UnityInterfaces_p = nullptr;

static GLuint s_VertexShader;
static GLuint s_FragmentShader;
static GLuint s_Program;
static GLint s_UniformTime;

static float s_TimeVal;


#if defined(DEBUG)
#define DEBUG_LOG(str) {\
	FILE* file = fopen("debug.log", "a"); \
	fwrite(str, 1, strlen(str), file); \
	fclose(file); \
}
#else
#define DEBUG_LOG(...)
#endif

#define AssertLogRV(condition, rv)\
{\
	if (!(condition)) {\
		DEBUG_LOG(#condition "\n");\
		return rv;\
	}\
}

#define AssertLog(condition) AssertLogRV(condition, )


static GLuint CreateShader(GLenum type, const char* sourceText, GLuint prev)
{
	AssertLogRV(sourceText != nullptr && glGetError() == GL_NO_ERROR, 0U);
	DEBUG_LOG(sourceText);

	// compile
	GLuint shaderH = (prev == 0U) ? glCreateShader(type) : prev;
	AssertLogRV(shaderH != 0U, 0U);
	glShaderSource(shaderH, 1, &sourceText, NULL);
	glCompileShader(shaderH);

#if defined(DEBUG)
	// check errors
	GLsizei log_length = 0;
	GLchar message[1024];
	glGetShaderInfoLog(shaderH, 1024, &log_length, message);
	if (log_length > 0) {
		DEBUG_LOG(message);
	}
	int compileState;
	glGetShaderiv(shaderH, GL_COMPILE_STATUS, &compileState);
	AssertLogRV(log_length == 0 && compileState == GL_TRUE && glGetError() == GL_NO_ERROR, shaderH);
#endif

	return shaderH;
}

static void __stdcall OnGraphicsDeviceEvent(UnityGfxDeviceEventType eventType)
{
	if (eventType == kUnityGfxDeviceEventShutdown) {
		if (s_VertexShader != 0U) {
			glDeleteShader(s_VertexShader);
		}
		if (s_FragmentShader != 0U) {
			glDeleteShader(s_FragmentShader);
		}
		if (s_Program != 0U) {
			glDeleteProgram(s_Program);
		}
	}
}

static void __stdcall OnRenderEvent(int /*eventID*/) // NOTE the assumption that we're only being called here for rendering
{
	if (s_Program == 0U) {
		return; // avoid crashing if called prematurely or after being given invalid shader code
	}

	// set basic render state
	AssertLog(glGetError() == GL_NO_ERROR);
	glDisable(GL_CULL_FACE);
	glDisable(GL_BLEND);
	glDepthFunc(GL_LEQUAL);
	glDisable(GL_DEPTH_TEST);
	glDepthMask(GL_FALSE);

	// render w/ shader program
	glUseProgram(s_Program);
	glUniform1f(s_UniformTime, s_TimeVal);
	glDrawArrays(GL_TRIANGLES, 0, 6);
	AssertLog(glGetError() == GL_NO_ERROR);
}


CEXPORT(bool) UpdateGLShader(const char *const pSrcDataVert, const char *const pSrcDataFrag)
{
	AssertLogRV(s_UnityInterfaces_p != nullptr, false);
	IUnityGraphics *const graphics_p = s_UnityInterfaces_p->Get<IUnityGraphics>();
	AssertLogRV(graphics_p != nullptr, false);
	static UnityGfxRenderer ApiType = graphics_p->GetRenderer();

	AssertLogRV(ApiType == kUnityGfxRendererOpenGL || ApiType == kUnityGfxRendererOpenGLES20 || ApiType == kUnityGfxRendererOpenGLES30 || ApiType == kUnityGfxRendererOpenGLCore, false);
	if (s_Program == 0) {
		// init system
#if SUPPORT_OPENGL_CORE
		if (ApiType == kUnityGfxRendererOpenGLCore) {
			glewExperimental = GL_TRUE;
			glewInit();
			glGetError(); // Clean up error generated by glewInit
		}
#endif // if SUPPORT_OPENGL_CORE
	} else {
		// clean up any errors we might be coming in with
		GLenum err;
		int failsafe = 0;
		do {
			err = glGetError();
			++failsafe;
		} while (err != GL_NO_ERROR && failsafe < 100);
	}
	AssertLogRV(glGetError() == GL_NO_ERROR, false);

	// create shaders
	AssertLogRV(pSrcDataVert != nullptr && pSrcDataFrag != nullptr, false);
	s_VertexShader = CreateShader(GL_VERTEX_SHADER, pSrcDataVert, s_VertexShader);
	s_FragmentShader = CreateShader(GL_FRAGMENT_SHADER, pSrcDataFrag, s_FragmentShader);
	AssertLogRV(s_VertexShader != 0U && s_FragmentShader != 0U, false);

	// link shaders into a program and find uniform locations
	bool reuseProgram = (s_Program != 0);
	s_Program = s_Program == 0 ? glCreateProgram() : s_Program;
	AssertLogRV(s_Program != 0U, false);
	if (!reuseProgram) {
		glAttachShader(s_Program, s_VertexShader);
		glAttachShader(s_Program, s_FragmentShader);
	}
#if SUPPORT_OPENGL_CORE
	if (ApiType == kUnityGfxRendererOpenGLCore) {
		glBindFragDataLocation(s_Program, 0, "fragColor");
	}
#endif // if SUPPORT_OPENGL_CORE
	glLinkProgram(s_Program);

	// check errors
	GLint status = 0;
	glGetProgramiv(s_Program, GL_LINK_STATUS, &status);
	AssertLogRV(status == GL_TRUE, false);

	s_UniformTime = glGetUniformLocation(s_Program, "t"); // NOTE that this can validly be 0 if the given source doesn't reference t

	AssertLogRV(glGetError() == GL_NO_ERROR, false);
	return true;
}

CEXPORT(void) UnityPluginLoad(IUnityInterfaces* unityInterfaces)
{
	AssertLog(unityInterfaces != nullptr);
	s_UnityInterfaces_p = unityInterfaces;
	IUnityGraphics* graphics_p = s_UnityInterfaces_p->Get<IUnityGraphics>();
	AssertLog(graphics_p != nullptr);
	graphics_p->RegisterDeviceEventCallback(OnGraphicsDeviceEvent);
	OnGraphicsDeviceEvent(kUnityGfxDeviceEventInitialize); // since this event can be missed depending on when the plugin is loaded
}

CEXPORT(void) UnityPluginUnload()
{
	UnregisterDeviceEventCallback(OnGraphicsDeviceEvent);
}

CEXPORT(void) SetTime(float t)
{
	s_TimeVal = t;
}

CEXPORT(UnityRenderingEvent) Execute()
{
	return OnRenderEvent;
}
